<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Thinking In Relay | Relay Docs</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="Thinking In Relay | Relay Docs"><meta property="og:type" content="website"><meta property="og:url" content="http://facebook.github.io/relay/index.html"><meta property="og:description" content="A JavaScript framework for building data-driven React applications"><link rel="shortcut icon" href="/relay/img/favicon.png"><link rel="stylesheet" href="/relay/css/relay.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/relay/"><img class="nav-logo" src="/relay/img/logo.svg" width="50" height="50">Relay</a><ul class="nav-site"><li><a href="/relay/prototyping/playground.html" class="">Try it out</a></li><li><a href="/relay/docs/getting-started.html#content" class="active">Docs</a></li><li><a href="/relay/support.html" class="">Support</a></li><li><a href="https://github.com/facebook/relay" class="">GitHub</a></li></ul></div></div><section class="content wrap documentationContent"><div class="nav-docs"><div class="nav-docs-section"><h3>Quick Start</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/getting-started.html#content">Getting Started</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/tutorial.html#content">Tutorial</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/thinking-in-graphql.html#content">Thinking in GraphQL</a></li><li><a style="margin-left:0;" class="active" href="/relay/docs/thinking-in-relay.html#content">Thinking In Relay</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/videos.html#content">Videos</a></li></ul></div><div class="nav-docs-section"><h3>Guides</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/guides-containers.html#content">Containers</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-routes.html#content">Routes</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-root-container.html#content">Root Container</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-ready-state.html#content">Ready State</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-mutations.html#content">Mutations</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-network-layer.html#content">Network Layer</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/guides-babel-plugin.html#content">Babel Relay Plugin</a></li></ul></div><div class="nav-docs-section"><h3>GraphQL</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/graphql-relay-specification.html#content">GraphQL Relay Specification</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-object-identification.html#content">Object Identification</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-connections.html#content">Connection</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-mutations.html#content">Mutations</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/graphql-further-reading.html#content">Further Reading</a></li></ul></div><div class="nav-docs-section"><h3>API Reference</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay.html#content">Relay</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-container.html#content">RelayContainer</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-route.html#content">Relay.Route</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-root-container.html#content">Relay.RootContainer</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-ql.html#content">Relay.QL</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-mutation.html#content">Relay.Mutation</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-proptypes.html#content">Relay.PropTypes</a></li><li><a style="margin-left:0;" class="" href="/relay/docs/api-reference-relay-store.html#content">Relay.Store</a></li></ul></div><div class="nav-docs-section"><h3>Interfaces</h3><ul><li><a style="margin-left:0;" class="" href="/relay/docs/interfaces-relay-network-layer.html#content">RelayNetworkLayer</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/interfaces-relay-mutation-request.html#content">RelayMutationRequest</a></li><li><a style="margin-left:20px;" class="" href="/relay/docs/interfaces-relay-query-request.html#content">RelayQueryRequest</a></li></ul></div></div><div class="inner-content"><a id="content"></a><a class="edit-page-link" href="https://github.com/facebook/relay/blob/master/docs/QuickStart-ThinkingInRelay.md" target="_blank">Edit on GitHub</a><h1>Thinking In Relay</h1><div><p>Relay 的資料抓取方法高度受到我們使用 React 的經驗啟發。尤其是，React 把複雜的界面拆成可重複使用的 <strong>component</strong>，讓開發者能獨立的去思考一個應用程式的個別部分，並減少應用程式不同部分之間的耦合。更重要的是，這些 component 是 <strong>declarative</strong> 的：它們讓開發者去指定 UI 針對給定的 state 應該看起來像<em>什麼樣子</em>，而不需要去擔心<em>如何</em>去呈現那個 UI。不同於以往那些使用 imperative 的指令去操作原生的 view (例如，DOM) 的方法，React 使用對 UI 的描述來自動地判斷需要的指令。</p><p>讓我們看一些產品的使用案例來了解我們如何把這些想法加進 Relay。我們會假設你對 React 有基本的熟悉。</p><h2><a class="anchor" name="view"></a>為 View 抓取資料 <a class="hash-link" href="#view">#</a></h2><p>根據我們的經驗，絕大多數的產品都想要一個特定的行為：在為 view 層級抓取<em>全部的</em>資料時顯示一個載入指示燈，並接著在一旦資料準備好的時候 render <em>整個</em> view。</p><p>一種解決方案是擁有一個 root component 為它的所有 children 抓取資料。不過，這會導致耦合：對 component 的每個變更都會需要改變<em>所有</em>可能會 render 它的 root component，而且時常還有它跟 root 之間的一些 component。這種耦合可能意味著有更大的機會造成 bug 並拖慢開發的步調。追根究底，這個方法沒有利用 React 的 component 模型。指定資料依賴關係最自然的地方就在 <em>component</em> 中。</p><p>下一個合乎邏輯的做法是使用 <code>render()</code> 作為觸發資料抓取的手段。我們可以簡單地先 render 應用程式一次，看它需要什麼資料，抓取那些資料，然後再 render 一次。這聽起來不錯，但問題是 <em>component 需要使用資料來計算出要 render 什麼東西！</em>也就是說，這會強迫資料抓取必須分階段：首先 render root 並看看它需要什麼資料，接著 render 它的 children 並看看它們需要什麼，一路往下走過整個 tree。如果每一個階段都引發網路請求，render 會需要很慢、連續的往返。我們需要一個方法來預先或<em>靜態地</em>決定所有的資料需求。</p><p>我們最終選擇靜態方法；components 會有效率地回傳一個 query-tree，從 view-tree 中分離，描述他們依賴的資料。Relay 接著可以使用這個 query-tree 在一個單一階段去抓取所有需要的資訊並使用它去 render 這些 component。問題是要找到一個適當的機制去描述 query-tree，還有一個能夠有效率地從伺服器抓取它的方法 (例如，在單一網路請求中)。這是 GraphQL 的完美使用案例，因為它提供一個語法來<em>依照資料描述資料依賴關係</em>，而不用操作任何特定的 API。需要注意的是，Promise 和 Observable 常被建議作為替代選擇，不過它們代表<em>不透明的指令</em>並妨礙了各種的優化，例如：批次處理 query。</p><h2><a class="anchor" name="component-container"></a>資料 Component 又名 Container <a class="hash-link" href="#component-container">#</a></h2><p>Relay 讓開發者們藉由建立 <strong>container</strong> 來標注他們的 React component 與其資料依賴關係。它們是包裝了原本的 component 的正規 React component。關鍵的設計限制是，React component 應該是可以重複使用的，因此 Relay container 也必須是如此。例如，<code>&lt;Story&gt;</code> component 會實作一個用來 render 任何的 <code>Story</code> 項目的 view。實際要 render 的 story 將會藉由傳遞到 component 的資料來決定：<code>&lt;Story story={ ... } /&gt;</code>。在 GraphQL 中的等價概念是 <strong>fragment</strong>：指定要抓取什麼資料<em>給一個給定 type 的物件</em>的命名 query 片段。我們可以如下描述 <code>&lt;Story&gt;</code> 需要的資料：</p><pre class="prism language-javascript">
fragment on Story <span class="token punctuation">{</span>
  text<span class="token punctuation">,</span>
  author <span class="token punctuation">{</span>
    name<span class="token punctuation">,</span>
    photo
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></pre><p>而這個 fragment 可以接著被用來定義 Story container：</p><pre class="prism language-javascript">
<span spellcheck="true" class="token comment">// 一般的 React component。</span>
<span spellcheck="true" class="token comment">// 用法：`&lt;Story story={ ... } /&gt;`</span>
<span class="token keyword">class</span> <span class="token class-name">Story</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span spellcheck="true" class="token comment">// 包了 `&lt;Story&gt;` 的「Higher-order」component</span>
<span class="token keyword">var</span> StoryContainer <span class="token operator">=</span> Relay<span class="token punctuation">.</span><span class="token function">createContainer</span><span class="token punctuation">(</span>Story<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  fragments<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span spellcheck="true" class="token comment">// 定義一個 fragment 有著符合上面預期的 `story` prop 的名稱</span>
    story<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Relay<span class="token punctuation">.</span>QL<span class="token template-string"><span class="token string">`
      fragment on Story {
        text,
        author { ... }
      }
    `</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></pre><h2><a class="anchor" name="render"></a>Render <a class="hash-link" href="#render">#</a></h2><p>在 React 中，render 一個 view 需要兩個 input：要 render 的 <em>component</em>，和一個要 render 進去的 <em>root</em> DOM (UI) node。Render Relay container 也類似：我們需要一個要 render 的 <em>container</em>，和一個 graph 中的 <em>root</em> 來從那邊開始我們的 query。我們也必須確保用於 container 的 query 有被執行並可能會想要在資料正在被抓取時顯示一個載入指示燈。類似於 <code>ReactDOM.render(component, domNode)</code>，Relay 也提供 <code>&lt;RelayRootContainer Component={...} route={...}&gt;</code> 來達成這個目的。那個 component 是要 render 的東西，而 route 則提供指定要抓取<em>哪個</em>東西的 query。下面是我們會如何去 render <code>&lt;StoryContainer&gt;</code>：</p><pre class="prism language-javascript">
ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>RelayRootContainer
    Component<span class="token operator">=</span><span class="token punctuation">{</span>StoryContainer<span class="token punctuation">}</span>
    route<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
      queries<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        story<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Relay<span class="token punctuation">.</span>QL`
          query <span class="token punctuation">{</span>
            <span class="token function">node</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span> <span spellcheck="true" class="token comment">/* 我們的 `Story` fragment 將會被加到這裡 */</span>
          <span class="token punctuation">}</span>
        `
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span>
  <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  rootEl
<span class="token punctuation">)</span></pre><p><code>RelayRootContainer</code> 可以接著協調這些 queries 的抓取；把它們跟快取的資料做比較，抓取任何遺漏的資訊，更新快取，並最後在資料可以使用時 render <code>StoryContainer</code>。在正在抓取資料時預設不 render 任何東西，不過這個載入的 view 可以藉由 <code>renderLoading</code> prop 來客製化。就像 React 讓開發者們 render view 不需要直接操作背後的 view，Relay 和 <code>RelayRootContainer</code> 則去掉了直接與網路溝通的需要。</p><h2><a class="anchor" name=""></a>資料遮罩 <a class="hash-link" href="#">#</a></h2><p>在典型的資料抓取方法，我們發現兩個 component 有<em>不明確的依賴關係</em>很常見。例如 <code>&lt;StoryHeader&gt;</code> 可能可以使用一些資料而不需要直接確保已經抓取了這些資料。這些資料時常也會被系統的一些其他部分抓取，例如：<code>&lt;Story&gt;</code>。接著當我們改變 <code>&lt;Story&gt;</code> 並移除它的資料抓取邏輯，<code>&lt;StoryHeader&gt;</code> 會突然莫名其妙的壞掉。這種類型的 bug 不總是立刻出現，特別是在更大的團隊開發的更大的應用程式裡。手動與自動測試能給的幫助很有限：這就是最好藉由框架來解決的系統問題類型。</p><p>我們已經看到 Relay container 會確保 GraphQL fragment 有在 component 被 render <em>之前</em> 被抓取。另外，container 也提供另一個不是顯而易見的好處：<strong>資料遮罩</strong>。Relay 只允許 component 存取它們在 <code>fragments</code> 中明確地要求的資料 — 僅此而已。所以如果一個 component 查詢 Story 的 <code>text</code>，而另一個查詢它的 <code>author</code>，彼此都<em>只</em>可以看到它們個別要求過的欄位。事實上，component 甚至看不到它們的 <em>children</em> 請求的資料：因為那也會破壞封裝。</p><p>Relay 還更進一步：它在 <code>props</code> 上使用不透明的識別符以驗證我們在 render component 之前已經明確地抓取了它的資料。如果 <code>&lt;Story&gt;</code> render <code>&lt;StoryHeader&gt;</code> 但是卻忘記要引入它的 fragment，Relay 會警告遺失了要給 <code>&lt;StoryHeader&gt;</code> 的資料。實際上，<em>即使</em>一些其他的 component 碰巧抓取了一些跟 <code>&lt;StoryHeader&gt;</code> 需要的一樣的資料，Relay 也會警告。這個警告告訴我們，雖然東西現在<em>可能</em>運作正常，但它們之後很有可能會壞掉。</p><h1><a class="anchor" name=""></a>總結 <a class="hash-link" href="#">#</a></h1><p>GraphQL 提供一個強大的工具來建置高效能、解耦的客戶端應用程式。Relay 建置在這樣的功能之上來提供一個 <strong>declarative 資料抓取</strong>的框架。透過把要抓取<em>什麼</em>資料跟<em>如何</em>抓取它分離，Relay 幫助開發者們建置強大、清楚、且高性能的應用程式。這對 React 倡導的以 component 為中心的思維是一個很好的補充。當這每一個技術 — React、Relay、以及 GraphQL — 都各自很強大，它們的組合是一個讓我們能<em>快速前進</em>並<em>釋出高品質且有規模的應用程式</em>的 <strong>UI 平台</strong>。</p></div><div class="docs-prevnext"><a class="docs-next" href="videos.html#content">Next →</a></div></div></section><footer class="wrap"><div class="right">©2016 Facebook Inc.</div></footer></div><div id="fb-root"></div><script>
            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
              ga('create', 'UA-71174216-1', 'auto');
              ga('send', 'pageview');
          </script></body></html>